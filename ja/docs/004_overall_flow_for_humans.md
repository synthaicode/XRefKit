<!-- xid: E01E6695A30A -->
<a id="xid-E01E6695A30A"></a>

# 全体の流れ（人間向け）

このリポジトリの目的は、PDF/Excel/Web などの元データをリポジトリ内に保管しつつ、AI が参照しやすい形（断片 Markdown）に整備し、改名・移動・分割・統合があってもリンクが破綻しにくい運用を実現することです。

副次的なメリットとして、AI ベンダーごとに異なる「指示ファイル」や「ルールファイル」を個別に直接更新し続けなくても、共通の運用（XID と `docs/`）を中心に据えて運用できます。ツールが変わっても知識の保管場所と参照方法が揺れにくく、移植や乗り換えのコストを下げられます。

運用の基本的な流れは、**`sources/`（原本） → `docs/`（抽出した断片） → Skill（知識を選んで使う） → `fm xref`（接続を保守） → CI（破綻検出）** です。

このページは、初めて使う人が「何をどこに置き、どんな順で作業するのか」を一枚で把握するための概要です。実際の作業は、(1)取り込み、(2)参照、(3)更新の 3 つに分けると理解しやすくなります。

## 主要な要素（正本と出典）

- `sources/`: 元データの保管庫（人間が確認するための出典）
  - 例: PDF、Excel、Webページの保存版（HTML）、画像、ログ
- `docs/`: 抽出結果の知識ベース（AIが読む正本）
  - 1ページ=1断片の Markdown にして XID を付ける
  - 各断片の末尾に出典（`sources/` のパス＋位置情報）を残す
- `fm/`: Skill と知識の接続を壊さないために、XID 付与・リンク整合・検査を担保する補助 CLI

ポイントは、**人間が確認する対象（出典）は `sources/`**、**AI が参照する正本は `docs/`**、という役割分担です。AI は通常 `docs/` を中心に作業し、必要なときだけ断片の出典情報を手がかりに `sources/` を参照します。

## クリティカルポイント: XID を変える判断

XID は参照の主キーです。そのため、XID を変えることは単なる機械的更新ではなく、**そのページが指している意味（サービス/機能/概念）の持ち方が変わる**ことを示唆します。

- 原則: 既存 XID は維持する（参照の意味を保つ）
- 例外: 意味が変わり「同じ XID のままでは別物になる」と判断した場合のみ、新 XID を作り、旧→新の関係を明示する

この判断は機械だけでは完結しません。`xref check --review` を材料にしつつ、最終的には人間がレビューします。XID を分ける場合は `xref deprecate` を使い、旧ページを残したまま後継へ誘導します。

## 運用の流れ（基本サイクル）

### 1) 取り込み（新しい資料を追加する）

1. 元データをそのまま `sources/` に追加する（分割は不要）
2. AI に必要な範囲だけを参照させ、`docs/` に断片 Markdown を追加/更新する
3. 断片の末尾に出典を残す（例: `source_path` と `page=` / `sheet=` / `source_url` など）
4. 最後に整合性コマンドを実行する（ローカルで実行できる場合）

```powershell
python -m fm xref init
python -m fm xref rewrite
python -m fm xref check
```

完了条件は `issues: 0` です。

### 2) 参照（作業中に確認したいことが出た）

参照は「元データを総当たりで読む」ではなく、まず `docs/` の断片を探して読むのが基本です。

1. まず `docs/000_index.md` を見る（入口）
2. `python -m fm xref search "<query>"` で候補 XID を探す
3. `python -m fm xref show <XID>` で必要な断片だけ読む

必要なら周辺もまとめて確認します。

```powershell
python -m fm ctx pack --seed <XID> --depth 1 --out .xref/pack.md
```

### 3) 更新（既存ドキュメントを直す・再編する）

- 文章の修正や追記は `docs/` を編集する
- 改名/移動/分割/統合を行ったら、最後に `xref rewrite` と `xref check` を必ず実行する（XID ブロックは消さない）
